## 1. 内存溢出

### 1.1 栈内存溢出。

思路： 描述栈定义，再描述为什么会溢出，再说明一下相关配置参数，OK的话可以给面试官手写是实现一个栈溢出的demo。

我的答案：

因为在JVM中，栈是线程私有的一块内存空间，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接等信息。

是随着线程的产生而产生的，就是生命周期是相同的。

那么这个时候，当线程请求的栈深度大于虚拟机允许的最大深度，就会造成StackOverFlow，一般就是方法递归调用产生，比如求斐波拉切数列用递归求，求第10000个数这种。

如果说虚拟机栈的大小可以动态扩展，并且已经扩展过了，但是无法请求到足够的内存去扩展，或者说新建线程的时候没有足够的内存去创建对应的虚拟机栈，那么就会造成OutOfMemory异常，这种一般是线程启动过多，比如说不断的创建线程。

可以通过参数 -Xss 去调整JVM栈的大小。



### 1.2 堆内存溢出

堆是JVM最大的一块内存，是用来存对象和数组的，所以当我们创建了大量的对象和数组的时候就会发生堆溢出。



### 1.3 常量池内存溢出

因为常量区存的都是常量，比如数字常量，字符串，方法或者域的引用，所以不断的往常量词中加字符串就有可能造成常量池溢出，所以在操作大量字符串的时候，用StringBuilder或者StringBuffer。intern方法就是查看方法区里面有没有这个字符串，没有就加进去，如果不用，字符串是存在堆里面的。

```java
int count = 0;
ArrayList<String> list = new ArrayList<>();
while(true)
{
    list.add(String.valueOf(count++).intern());
}
```



### 1.3 方法区内存溢出

方法区是用来存储运行时常量池，域，方法数据，方法体，构造函数，就是Class相关的数据。所以如果一次性产生了大量的类，导致来不及回收旧会造成方法区内存溢出。

## 2.JAVA内存模型

分为线程共享和线程私有两块部分:

- 线程共有：堆，方法区
- 线程私有：虚拟机栈，本地方法栈，程序计数器

**堆：**最大的一块儿内存区域，用来对对象和数组，GC回收的高频地方，还可以细分为新生代和老年代，新生代分为Eden和两个Survior区。

**方法区：**存放已经被加载的类信息，运行时常量池等等。

**虚拟机栈：**存放基本数据类型，对象的引用，方法出口等。

**本地方法栈：**和虚拟机栈差不多，只是用于Native方法。

**程序计数器：**存放当前线程执行的字节码的行号指示器，也就是说执行到哪一行了

- 用处1：流程控制，循环，选择等等结构，代码执行到什么地方了。
- 用处2：多线程条件下，线程切换再切换回来后，知道自己执行到什么地方了，接着运行。
- 是JVM内存区域中永远不会发生内存溢出的区域。



## 3.JVM内存为什么要分成新生代，老年代

都是为了内存回收，因为对象是在新生代里面创建，所以这里的对象存活率就很低，老年代里面的对象一般不怎么变动，这样就有了区分，再进行GC的时候，新生代是重点照顾对象。



## 4.新生代中为什么要分为Eden和Survivor

新生代为什么要分为Eden和survior是为了解决：

- 如果没有Survior,Eden每进行一次GC，存活的对象都会被送到老年代中，老年代很快就会被填满，触发Major GC,而老年代的空间原大于新生代,这样GC的代价太大了。
- Survior有一个筛选机制，默认情况上只有年龄大于16的对象才会被送到老年代中，这样老年代发生GC的概率就减少了。
- 那么为什么要设置两个Survior区呢，主要是为了解决空间碎片化，发生一次Eden GC，存活对象会被送到Survior0，然后下一次Eden满了再GC的时候，就会把Eden和Survior0一起复制到Survior1中，然后保证有一块Survior是空的，这样就可以避免空间的碎片化。



## 5.JMM

Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。



## 6.怎么打破双亲委派模型

方法1：

1. 继承ClassLoader
2. 重写loadClass方法，定义自己的处理范围，其他的类调用父类的加载器即可。



### 7.说说你知道的几种主要的JVM参数

```shell
-Xmx 3550m： 最大堆大小为3550m。

-Xms 3550m： 初始堆大小为3550m。

-Xmn 2g： 设置年轻代大小为2g。

-Xss 128k： 每个线程的堆栈大小为128k。

-XX: NewRatio=4: 设置年轻代（包括Eden和两个Survivor区）与老年代的比值（除去持久代）。

-XX: SurvivorRatio=4： 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6

-XX: MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。
```



## 8.JAVA怎么进行线上内存溢出问题排查

**1、使用top对当前服务器内存有个大致了解**

​	top后 shift+M俺内存占用由大到小排序

**2、利用ps命令查看服务pid**

​	``ps -aux|grep java``

**3、利用jstat查看虚拟机gc情况** 

```shell
jstat  -gc:util <vmid>  [<interval> [<count>]
vmid：虚拟机进程号
interval:采样时间，默认单位是ms
count：采样条数

# 查看17561号进程，每一秒钟采样一次，一共采样10次
demo: jstat -gcutil 17561 1000 10
```

​	如果FULL GC明显大于YOUNG GC次数，并且FULL GC次数很频繁，说明程序有大内存对象，并且一直无法释放。

**4、生成dump文件**

​	有两种方式。 一种是利用jmap直接生成dump文件；另一种是利用gcore先生成core文件，再根据core文件利用jmap生成dump文件。

**5、利用MAT或者 jdk自带的jvisualvm.exe 来分析dump文件**

​	定位哪些对象在FGC之后还活着，哪些对象占大部分内存，软件会提示可能存在的内存泄漏



# synchronized锁竞争、锁升级过程、可重入锁

