## Redis基础

### 1.简单介绍一下 Redis 

简单来说 **Redis 就是一个使用 C 语言开发的数据库**，不过与传统数据库不同的是 **Redis 的数据是存在内存中的** ，也就是它是<font color='red'>内存数据库</font>，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。

另外，**Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。**

**Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。**



### 2.缓存数据的处理流程

1. 如果用户请求的数据在缓存中就直接返回。
2. 缓存中不存在的话就看数据库中是否存在。
3. 数据库中存在的话就更新缓存中的数据。
4. 数据库中不存在的话就返回空数据。



### 3.Redis的数据类型

1. String

2. list

3. hash

4. set

5. sorted set

6. bitmap

   

### 4.Redis 单线程模型详解

​	**Redis**是基于**Reactor** 来设计的一套高效的事件处理模型，对应的就是文件事件处理器（file event handler），因为文件事件处理器是单线程的，所以我们一般称**Redis**是单线程的。单线程的情况下是如何处理大量的客户端请求的呢？通过I/O多路复用，来监听多个套接字，并根据套接字目前执行的任务关联不同的事件处理器，当套接字准备执行应答（accept），读取（read），写入（write），关闭（close）等操作时，就会生成对应的文件事件，然后文件事件处理器就会调用之前关联好的事件处理器来处理这些事件。

文件事件处理器的4个部分：

1. 大量的套接字socket（客户端请求）
2. I/O多路复用程序
3. 文件事件分派器
4. 具体的事件处理器（连接应答，命令请求，命令回复等）

![image-20210727150859102](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20210727150859102.png)



### 5.Redis6.0 之后为何引入了多线程

​	主要是为了<font color='red'>提高网络IO数据读写</font>。因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。



### 6.Redis 给缓存数据设置过期时间有啥用？

- 如果所有数据不设置过期时间的话，内存会很快不够用，out of memory

- 我们有时候只希望数据存在于某个时间段，比如用户登录的token只存在一天，短信验证码只有效30分钟等等，方便快捷。

  

### 7.Redis 是如何判断数据是否过期的呢？

​	有个过期字典，可以看做是hash表，server.db[i].expires 存了所有设置了过期时间的key和对应的过期时间戳（精确到毫秒）。



### 8.过期的数据的删除策略了解么

​	redis采用了惰性删除和定期删除策略共同执行。

- 惰性删除

  只有在进行取值的时候，采取检查对应的key的过期事件是否到期，到期了就删除并返回空。

- 定期删除

  每隔一段时间就删除一些数据。

通过两者的描述，我们就可以知道：

- 惰性删除对cpu是友好的，不会长时间占用cpu来执行删除操作，但是对内存是不友好的，因为不取值就不检查，内存占用就大了。

- 定期删除对内存是友好的，但是对cpu不友好，因为需要长时间占用cpu来进行删除。redis也会限制其执行时间。

但是有这样的机制还是不够，还是可能会出现大量的已经过期的key存在于内存中，这时候再存就会导致out of memory，所以就有了Redis的内存淘汰机制来保证，当插入的时候空间不够了，怎么办？



### 9.Redis 内存淘汰机制了解么？

> 相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?

​	一共有8种机制，其中两种是在redis4.0之后才引入的。

1. volatile-lru                     在设置了过期时间的键中，选择最近最少使用的进行淘汰
2. volatile-ttl                      在设置了过期事件的数据中，选择快要过期的进行淘汰
3. volatile-random            在设置了过期时间的数据中进行随机删除
4. <font color='red'>allkeys-lru                      在所有数据中，选择最近最少使用的进行淘汰  （最常用）</font>
5. allkeys-random             在所有数据中，选择随机的进行淘宝
6. no-evication                   不准删

4.0之后添加的两种

	7. volatile-lfu                       在设置了过期时间的键中，选择最不经常使用的进行淘汰
 	8. allkeys-lfu                        在所有数据中，选择最不经常使用的进行淘汰



### 10.Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)

<font color='red'>	Redis持久化有两种机制，一种叫快照（snapshoting，RDB文件），一种叫做只追加文件aof（append-only file，aof文件）。</font>

​	快照(默认方式)：

​			在某个时间点的副本。通过save time changecount 来进行备份。比如

```conf
save 900 10 # 在900s内，如果有10个键发生变化 ，就创建快照
```

 	只追加文件（通过  `appendonly yes`  开启）：

​			三种模式。

```java
appendfsync always    #  每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #  每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #  让操作系统决定何时进行同步
```

redis4.0之后可以混合持久化，同时开启快照和aof，当发生aof重写的时候，直接将rdb的内容放在aof文件的开头，可以快速加载同时避免丢失过多的数据，就是可读性差了点。

**aof重写：**

​	<font color='red'>aof文件会随着时间不断的越来越大，这时候我们就需要减小aof文件的体积</font>，我们不需要去对原aof文件进行任何读取写入操作，我们直接对数据库进行读取并写入，比如aof里面连续进行了6次操作，每次写入了一个值，这样就有6条命令，那我们读取数据库进行重写，就可以写成一条命令了，极大了减少了体积。不过aof重写的时候，我们还在处理请求，这时候就有可能会出现数据不一致的问题，我们采取的策略就是创建一个缓冲区，将重写期间执行的写命令存入缓冲区，当创建新aof文件完毕后就直接将缓冲区的内容追加到新aof文件中，并进行aof文件替换。



### 11.Redis 事务

​	事务有几条命令。multi，exec，discard,watch。

流程：

1. 使用multi 开启事务
2. 输入一系列命令，命令会存入队列中
3. 使用exec提交，并执行命令

```redis
> MULTI
OK
> SET USER "Guide哥"
QUEUED
> GET USER
QUEUED
> EXEC
1) OK
2) "Guide哥"
```

使用discard可以取消一个事务。

watch可以监听指定的键，当在事务中修改了被watch的键，事务就不会执行，直接返回失败。

<font color='red'>Redis的事务是不满足原子性的，持久性的。</font>



### 12.缓存穿透

​	首先了解一下缓存的处理流程，当我们请求一个数据的时候，首先到缓存里面去取，如果缓存有就只有返回，要是没有就查询数据库并更新缓存。

​	这个时候就会出现大量的key在缓存中没有，全部都来查询数据库了，导致数据库压力剧增。比如某个攻击者故意写一些不存在的key来查询，导致大量请求落在数据库上。

解决的办法：

1. 首先需要做好参数校验，对一些明显不存在的key根本就不要发起请求，比如邮箱格式不对，用户ID小于0等各种情况。

2. 缓存无效key。我们遇到一个无效key就写一个到redis中，并设置一个过期时间，并且尽量设置的短一点。

3. 布隆过滤器。

   布隆过滤器可以快速的判别有没有数据，运用到的就是hash，使用布隆过滤器的哈希函数对元素值进行计算，然后根据得到的hash值将位数组中对应的位置设为1. 判断在不在就是对元素值进行相同的hash计算，然后判定对应位是不是都为1，如果有一个不为1，那就是不存在。同样我们还知道一个事实，那就是<font color='red'>hash碰撞</font>，不同的元素映射到了相同的hash值上，所以我们说<font color='red'>布隆过滤器说有的数据可能没有，但是布隆过滤器说没有的数据一定没有。</font>

   

### 13.缓存雪崩

实际上，缓存雪崩描述的就是这样一个简单的场景：**缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。** 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。

举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。

还有一种缓存雪崩的场景是：**有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。** 这样的情况，有下面几种解决办法：

举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。

#### 有哪些解决办法？

**针对 Redis 服务不可用的情况：**

1. 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
2. 限流，避免同时处理大量的请求。

**针对热点缓存失效的情况：**

1. 设置不同的失效时间比如随机设置缓存的失效时间。
2. 缓存永不失效。



## Redis进阶



