## 使用到的技术

- SpringBoot  前后端分离
- Redis 缓存
- RabittMQ 消息中间件
- Jmter 压测工具 
- Nginx 软件负载均衡

## Redis封装

1. 引入Jedis的依赖
2. 写一个Jedis的配置类 ，配置redis的相关信息`` host``，``port``等
3. 写一个JedisPoolFactory类，向Spring中注入JedisPool实例
4. 写一个服务类，通过JedisPool获取redis连接

**扩展：**

1. 为了避免key重复，可以类名设置key的前缀，比如有一个用户服务,那就可以建立一个UserKey

   这样设置用户服务的时候会带上UserKey前缀

2. 通用缓存key的封装。通过接口->抽象类->具体类，接口抽取逻辑，抽象类实现公用的默认逻辑实现，具体类实现特定的实现。

   

## 登录加密

1.前端获取输入密码 并通过MD5加Salt加密

2.后端获取到之后，也加Salt再MD5加密，和数据库中的用户密码进行对比。

**注意：**

1.使用的加密函数为commons中DeigestUtils.md5Hex()函数。



## 全局异常处理

1.使用<font color='red'>``@ControllerAdvice``</font>表明一个类是异常处理类，后序发生了异常都会通过这个类处理

2.在这个类中 通过 ``exception instance of xxException``，为不同的异常定义不同的处理逻辑

3.在实际使用时，处理业务逻辑时，发生了异常直接往外抛异常就可以了



## 秒杀简单步骤

1. 判断库存 
   1. 库存不够返回秒杀失败
2. 如果库存够，判断是否已经秒杀成功
   1. ·如果没有秒杀，就秒杀 
      1. 减库存 下订单 写秒杀订单（事务）



## JMeter压测

1. JMeter入门
2. 自定义变量模拟多用户
3. JMeter命令行使用
4. Redis压测工具 redis-benchmark

**步骤**

1. 测试计划 添加一个线程组 
   - 一些参数说明
     - 线程数 就代表并发数
     - Ramp-up Period（in seconds） 所有线程在多少秒钟全部启动起来
     - 循环次数
2. 在线程组 配置
   1. HTTP请求默认值 
   2. HTTP请求 （路径和参数）
   3. 监听器-聚合报告
3. 出问题怎么检测 只开一个线程 并添加结果树 可以看到单个线程的请求过程和结果



## 页面优化技术

1.页面缓存+URL缓存+对象缓存（前后端不分离的） 热点页面数据 比如秒杀商品页面

- 在redis取页面缓存，看一下是否有缓存，就取
- 没有，就通过视图解释器，手动渲染，并存入缓存之中

2.页面静态化，前后端分离

- 利用浏览器的缓存


3.静态资源优化



4.CDN优化



## 秒杀问题

<font color='red'>超卖问题 </font>

**解决办法**：

- 数据库 判断当前库存是否大于0  大于0才减

<font color='red'>一人发了两个请求 同时走到了最后一步 ，在库存充足的时候导致秒杀到了两件商品</font>

- 验证码 让一次性不能发多个请求 也有削峰降流的作用
- 通过唯一索引解决    商品订单表 和    秒杀订单表，在秒杀订单表建立唯一索引

**优化**：

生成订单后，将订单缓存到redis中，后面再次有秒杀请求之后，判断缓存中是否有对应订单，如果有就 代表已经秒杀过了。没有就查询数据库。

