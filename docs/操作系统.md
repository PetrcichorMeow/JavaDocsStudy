### 1.1 什么是操作系统？

​	操作系统是管理计算机硬件和计算机软件的程序，本质上就是一个软件，其屏蔽了底层硬件操作的复杂性，操作系统的内核是其核心部分，作为连接计算机硬件和软件的桥梁，其实现的好坏，直接影响着整个计算机系统的稳定性和性能。

### 1.2 系统调用

​	在讲系统调用之前，我们要明白两个名词，用户态和系统态，处于用户态的进程只能读取整个用户程序的数据，处于系统态的进程几乎可以读取计算机的所有资源，不受任何限制，那么问题来了，处于用户态的进程想要调用系统态的功能怎么办呢？就是用过系统调用的方式来进行，那么系统调用按照功能划分分为以下4类：内存管理，设备管理，文件管理，进程管理。

### 2.1 进程和线程的区别

​	进程是计算机系统的最小单位，线程是运行的最小单位，一个进程可以包含多个线程，进程和进程之间一般来讲没什么通信，而线程之间的通信较为频繁，进程开销大，易于资源管理和回收，线程反之反是。

### 2.2 进程有哪几种状态?

​	在java当中，进程有以下的5种状态：

1. `创建状态` 对象实例化
2. `就绪状态` 获得除CPU之外的一切资源，等待时间片开始运行
3. `运行状态` 获得时间片 开始运行
4. `阻塞状态` 因为锁或者等待其他资源 陷入等待状态，在此期间，即使处理器空闲，也不能进入运行状态。
5. `消亡状态` 程序正常结束或者因为中断等原因，程序终止的状态。

### 进程间的通信方式

​	7种。

1. 管道
2. 有名管道
3. 信号
4. 信号量
5. 消息队列
6. 共享内存
7. 套接字

### 2.4 线程间的同步的方式

​	3种。

1. 互斥量
2. 信号量
3. 事件

### 2.5 进程的调度算法

​	5种。

1. 先到先服务
2. 短作业优先
3. 时间片轮转
4. 多级反馈调度队列
5. 优先级队列

### 什么是死锁

​	死锁是因为进程占有某个资源，还等待其他资源，但是该资源被其他进程占有，从而该进程的状态不会改变的一种状态。

### 死锁的四个条件

1. 互斥
2. 占有并等待
3. 非抢占
4. 循环等待

## 三 操作系统内存管理基础

### 3.1 内存管理介绍

​	操作系统的内存管理主要负责内存的分配与回收，还包括地址转换等。

### 3.2 常见的几种内存管理机制

​	内存管理分为连续和非连续。连续的是很古老的方法了，容易造成极大的空间浪费。如

1. 块式管理。

非连续：

1. 页式管理
2. 段式管理
3. 段页式管理

### 3.3 快表和多级页表

​	在页式存储管理中，我们首先要解决的两个问题是：

1. 快速完成从逻辑地址到物理地址的查找映射
2. 避免因虚拟地址空间过大，导致页表空间占用过大问题

#### 快表 （为了解决问题一）

​	快表实际上就是缓存。

#### 多级页表（为了解决问题二）

​	多级页面运用了局部性原理，将不用的页表存储在磁盘硬盘中，需要中再去构建，典型的属于用时间换空间的方法。



### 3.4 分页机制和分段机制的共同点和区别

共同点：

1. 都是为了提升空间利用率，减少空间碎片。

不同点：

1. 分页的页表没有实际意思，仅仅只是为了内存管理，但是分段，段带有逻辑信息，比如划分为逻辑段，主程序段，方法段等等，更好的满足用户需要。
2. 分页的页大小是固定的，是由操作系统决定的，但是分段的大小是由当前的运行程序决定的。

### 逻辑(虚拟)地址和物理地址

​	我们平常使用的就是逻辑地址，通过逻辑地址操作物理地址。

### 3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?

​	如果没有虚拟地址空间的话，直接操作物理地址，容易造成混乱。比如有两个进程，微信和QQ，微信在A地址写入了一个数据，这个数据对于微信而言，这时候QQ也去修改了A地址的数据，那么微信就奔溃了，再推广开来讲的，操作系统就奔溃了，所以需要加一层逻辑地址来保护，不同进程的逻辑地址相互隔离，同样的其对应的物理地址也互相隔离，也容易实现连续的虚拟空间地址调用位置不相邻的物理地址空间。

## [四 虚拟内存](https://snailclimb.gitee.io/javaguide/#/docs/operating-system/basis?id=四-虚拟内存)

### 4.1 什么是虚拟内存(Virtual Memory)?

​	虚拟内存运行了局部性原理。

### [4.2 局部性原理

​	时间局部性。

​	空间局部性。

### [4.3 虚拟存储器

​	同虚拟内存。

### [4.4 虚拟内存的技术实现

1. ​	请求页式管理
2. 请求段式管理
3. 请求段页式管理

### [4.5 页面置换算法

1. ​	opt（最佳页面置换算法）
2. 先进先出算法
3. LRU（最近最久未使用）
4. LFU（最少未使用）
