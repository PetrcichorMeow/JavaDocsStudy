## 并发

### 1 什么是进程和线程？

**进程：**进程就是程序的一次执行过程，是**系统运行程序的基本单位**，系统运行一个程序就是一个进程从**创建，运行到消亡**的过程。

**线程：**线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。Java程序天生就是多线程程序。

### 2 线程与进程的关系，区别，以及优缺点

![image-20210715084823777](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20210715084823777.png)

#### 2.1程序计数器：

较小的一块内存空间，可以看做执行的字节码的行号指示器。两个作用：

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现程序的流程控制，比如分支，循环，选择等等。
2. 在多线程条件下，切换线程后，用于记录当前线程执行的位置，从而切换线程后知道当前线程执行到哪儿了。

**注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**



#### 2.2 Java虚拟机栈

Java虚拟机栈有一个个栈帧组成，每个栈帧里面都有：局部变量表、操作数栈、动态链接、方法出口等信息。

**Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。**

- **StackOverFlowError：** 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。
- **OutOfMemoryError：** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常

局部变量表：存放的是方法参数和方法内定义的局部变量

操作数栈：用于运算的地址空间。

动态链接：每个栈帧中有一个指向运行时常量池中该栈所属方法的符号引用，如果在类加载阶段或者第一次使用的时候，将符号引用转化为直接引用，就是静态解析或者静态链接。如果是在每次运行区间转化为直接引用，这类转化为就被称为动态链接。

方法出口：保存方法返回值的地址（上层调用者），或者异常提出对应的异常处理表的对应地址。



#### 2.3 本地方法栈

与Java虚拟机栈类似，不同的是Java虚拟机栈为虚拟机执行字节码服务，但是本地方法栈为虚拟机使用到的Native方法服务，其他类似。



#### 2.4 堆

堆内存是Java虚拟机管理的内存中最大的一块，是所有线程共享的，虚拟机启动后，此内存区域的唯一目的就是存放对象示例，几乎所有的对象示例以及数组都是存放在此区域中。

堆又被称为GC堆（Garbage Collected Heap），由于垃圾收集器都是采用分代算法，又被分为新生代，老年代，永久代，其中永久代在JDK1.8后被替换成了元空间，元空间使用的物理内存，受到宿主机的内存限制，永久代使用的是堆内存空间。

内存分配一般在Eden区分配，但是大对象或者大数组直接在老年代分配，可以通过-XX:PretenureSizeThreshold设置，默认为0

-XX:MaxTenuringThreshold 对象动态晋升年龄



#### 2.5 方法区

**方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。**

HotSpot 虚拟机中方法区也常被称为 **“永久代”**，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。

**相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。**

常量：final 修饰的  不可改变

静态变量：static修饰的 属于类的变量

即时编译器：JIT



#### 2.6 运行时常量池 

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）

既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

**JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

![image-20210714104612177](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20210714104612177.png)

```shell
JVM参数简介
-XX 参数被称为不稳定参数，之所以这么叫是因为此类参数的设置很容易引起JVM 性能上的差异，使JVM 存在极大的不稳定性。如果此类参数设置合理将大大提高JVM 的性能及稳定性。
不稳定参数语法规则：
    1.布尔类型参数值
        -XX:+<option> '+'表示启用该选项
        -XX:-<option> '-'表示关闭该选项
    2.数字类型参数值：
        -XX:<option>=<number> 给选项设置一个数字类型值，可跟随单位，例如：'m'或'M'表示兆字节;'k'或'K'千字节;'g'或'G'千兆字节。32K与32768是相同大小的。
    3.字符串类型参数值：
        -XX:<option>=<string> 给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。 例如：-XX:HeapDumpPath=./dump.core


-Xms 初始化堆空间大小
-Xmx 最大堆空间大小
-Xmn 新生代空间大小
-Xss 每个线程栈空间大小
-XX：SurviorRatio Eden和Survior的比值大小 默认为8:1:1
-XX：NewRatio 设置老年代和新生代的大小 默认为2
```





### 3 并发和并行的区别

**并发：**并发是指多线程，也就是在一段时间内，多个任务都在执行。

**并行：**并行指多核CPU，在单位时间内，多个任务同时运行。



### 4. 使用多线程可能带来什么问题?

并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：**内存泄漏、死锁、线程不安全**等等。



### 5 线程的生命周期和状态

线程生命周期有6个状态，任一时刻运行中的线程只会处于其中一种状态:

- 初始状态   线程被创建出，但是还没有调用start()方法
- 运行状态   Java笼统的将操作系统中的就绪和运行两种状态称为运行中
- 阻塞状态   线程被锁阻塞了
- 等待状态   进入了等待状态，代表需要等到其他线程做操作（通知或者中断）
- 超时等待状态   不同于等到状态，而是设置了超时时间，过了超时时间自动返回
- 终止状态   代表当前线程已经执行完毕

![image-20210715095117105](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20210715095117105.png)

### 6 什么是上下文切换

在多线程编程中，线程的个数一般都多于核心的个数，在任一时刻，CPU核心只能处理一个线程，所以CPU采取的策略就是分配时间片并轮转，当一个线程的时间片用完后，其就重新处于就绪状态，将CPU核心让给其他线程使用，这就是一次上下文切换。（上下文切换比较耗费时间）



### 7 什么是线程死锁，如何避免

线程死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

学过操作系统的朋友都知道产生死锁必须具备以下四个条件：

> 1. 互斥条件：该资源任意一个时刻只由一个线程占用。
> 2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
> 3. 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
> 4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。



sleep()方法和wait()方法 

- sleep不会释放锁，但是wait会释放锁

- 两者都能暂停线程

- wait通常用于线程间交互通信，sleep通常用于暂停线程

- wait不会自动苏醒，需要其他线程执行notify或者notifyAll方法，或者使用wait(long timeout), sleep可以自动苏醒。

  

## 并发进阶

### 说说自己对synchronized的理解

`synchronized`关键字解决的是多个线程之间访问资源的同步性，`synchronized`关键字可以保证被它修饰的方法或者代码块在任一时刻只能有一个线程执行。

另外，在 Java 早期版本中，`synchronized` 属于 **重量级锁**，效率低下。

**为什么呢？**

因为监视器锁（monitor）是依赖于底层的操作系统的 `Mutex Lock` 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。

庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 `synchronized` 较大优化，所以现在的 `synchronized` 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

所以，你会发现目前的话，不论是各种开源框架还是 JDK 源码都大量使用了 `synchronized` 关键字。



### 使用synchronized的三种方法

1. **修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁**

   ```java
   synchronized void method()
   {
       //业务代码
   }
   ```

   

2. **修饰静态方法:**也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**。因为静态成员不属于任何一个实例对象，是类成员（ _static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份_）。所以，如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，**因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁**。

   ```java
   synchronized static void method()
   {
       //业务代码
   }
   ```

   

3. **修饰代码块:**指定加锁对象，对给定对象/类加锁。`synchronized(this|object)` 表示进入同步代码库前要获得**给定对象的锁**。`synchronized(类.class)` 表示进入同步代码前要获得 **当前 class 的锁**

   ```java
   synchronized(this)
   {
        //业务代码
   }
   ```

   

**总结：**

- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是是给 Class 类上锁。
- `synchronized` 关键字加到实例方法上是给对象实例上锁。
- 尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能！

**知识点：**可以用双重检验锁实现单例模式， 在单例对象定义上需要使用`volatile`，可以禁止JVM的指令重排，保存在多线程环境下也能正常运行。

### 底层实现

`synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。

`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。

**不过两者的本质都是对对象监视器 monitor 的获取。**

### 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗

JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

### volatile关键字

### 并发编程的三个重要特性

1. **原子性** : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。`synchronized` 可以保证代码片段的原子性。
2. **可见性** ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。`volatile` 关键字可以保证共享变量的可见性。
3. **有序性** ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。`volatile` 关键字可以禁止指令进行重排序优化。

### 说说 synchronized 关键字和 volatile 关键字的区别

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在！

- **`volatile` 关键字**是线程同步的**轻量级实现**，所以 **`volatile `性能肯定比`synchronized`关键字要好** 。但是 **`volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块** 。

- **`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。**

- **`volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。**




# synchronized锁竞争、锁升级过程、可重入锁

锁分为四种状态，无锁，偏向锁，轻量级锁，重量级锁。

以前要对一个对象上锁的话，都需要去找操作系统申请锁，效率比较低，因为涉及到用户态和内核态的一个转换。改进之后，都是在JVM层面进行加锁机制，效率就变高了。

 当只有一个线程的时候，在对象头的markword中将记录当前的线程，标志这个对象已经有人占用了，锁状态位为01，这个时候就是偏向锁。

当我们的偏向锁有线程争用的时候，就升级为轻量级锁，把锁的ID拷贝一份到自己的线程栈中，同时锁状态位为00

当自旋10次都没有抢到锁的话，就会升级为重量级锁，就向操作系统申请锁，锁状态位为10







### CAS

CAS 全称是 compare and swap，即比较并交换，它是一种原子操作，同时 CAS 是一种乐观机制。

CAS 的思想很简单：**三个参数，一个当前内存值 V、旧的预期值 A、即将更新的值 B，当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true，否则什么都不做，并返回 false**。

举例分析：

1. 设定 AtomicInteger 的 value 原始值为 A，从 Java 内存模型得知，线程 1 和线程 2 各自持有一份 value 的副本，值都是 A。
2. 线程 1 通过`getIntVolatile(var1, var2)`拿到 value 值 A，这时线程 1 被挂起。
3. 线程 2 也通过`getIntVolatile(var1, var2)`方法获取到 value 值 A，并执行`compareAndSwapInt`方法比较内存值也为 A，成功修改内存值为 B。
4. 这时线程 1 恢复执行`compareAndSwapInt`方法比较，发现自己手里的值 A 和内存的值 B 不一致，说明该值已经被其它线程提前修改过了。
5. 线程 1 重新执行`getIntVolatile(var1, var2)`再次获取 value 值，因为变量 value 被 volatile 修饰，所以其它线程对它的修改，线程 A 总是能够看到，线程A继续执行`compareAndSwapInt`进行比较替换，直到成功。<font color='red'>（自旋）</font>

