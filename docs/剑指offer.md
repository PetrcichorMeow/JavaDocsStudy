## 1.1 算法

> 作者：微凉。
>
> **介绍:** 学习算法的一个small white.

## 1.2剑指offer

### 38字符串的排列

原文地址：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/

- 解题思路

对于一个长度为 N的字符串（假设字符互不重复），其排列方案数共有：N x（N-1）x（N-2）x ... x 1

- 排列方案的生成：


根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 1位字符（ n 种情况）、再固定第 2位字符（ n−1 种情况）、... 、最后固定第 n位字符（ 1 种情况）。

![Picture1.png](https://pic.leetcode-cn.com/1599403497-KXKQcp-Picture1.png)

- 重复排列方案与剪枝：


当字符串存在重复字符时，排列方案中也存在重复的排列方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。

![Picture2.png](https://pic.leetcode-cn.com/1599403497-GATdFr-Picture2.png)

- 递归解析：

  1. 终止条件： 当 x = len(c) - 1 时，代表所有位已固定（最后一位只有 11 种情况），则将当前组合 c 转化为字符串并加入 res ，并返回；

  2. 递推参数： 当前固定位 x ；

  3. 递推工作： 初始化一个 Set ，用于排除重复的字符；将第 x 位字符与 i \in∈ [x, len(c)] 字符分别交换，并进入下层递归；

     1. 剪枝： 若 c[i] 在 Set 中，代表其是重复字符，因此 “剪枝” ；

     2. 将 c[i] 加入 Set ，以便之后遇到重复字符时剪枝；

     3. 固定字符： 将字符 c[i] 和 c[x] 交换，即固定 c[i] 为当前位字符；

     4. 开启下层递归： 调用 dfs(x + 1) ，即开始固定第 x + 1 个字符；

     5. 还原交换： 将字符 c[i] 和 c[x] 交换（还原之前的交换）；

        

```java
class Solution {
    //s的字符数组
    char[] c ;
    //存放返回结果的list
    List<String> res = new LinkedList<>();
    public String[] permutation(String s) {
        c = s.toCharArray();
        dfs(0);
        return res.toArray(new String[res.size()]);
    }
    public void dfs(int x)
    {
        if(x == c.length-1)
        {
            res.add(String.valueOf(c));
            return;
        }
        HashSet<Character> set = new HashSet<>();
        for(int i=x;i<c.length;i++)
        {
            if(set.contains(c[i]))
            {
                continue;
            }
            set.add(c[i]);
            swap(x,i);
            dfs(x+1);
            swap(x,i);
        }
    }
    void swap(int a, int b) {
        char tmp = c[a];
        c[a] = c[b];
        c[b] = tmp;
    }
}
```

### 39数组中出现次数超过一半的数字

- 解题思路

  这道题可以用摩尔投票法。

- 相关题目：数组中出现次数超过n/1的数字都可以用摩尔投票法，同时可以类比为选择投票，比如有n个人，选两个人为候选人，根据少数服从多数原则，候选人得到的推荐票至少要超过1/3，就类比为了这道题，还有求总数也是。

- Boyer-Moore 投票算法
  思路

如果我们把众数记为 +1+1，把其他数记为 -1−1，将它们全部加起来，显然和大于 0，从结果本身我们可以看出众数比其他数多。

算法

Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：

我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；

我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：

如果 x 与 candidate 相等，那么计数器 count 的值增加 1；

如果 x 与 candidate 不等，那么计数器 count 的值减少 1。

在遍历完成后，candidate 即为整个数组的众数。

我们举一个具体的例子，例如下面的这个数组：

[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
在遍历到数组中的第一个元素以及每个在 | 之后的元素时，candidate 都会因为 count 的值变为 0 而发生改变。最后一次 candidate 的值从 5 变为 7，也就是这个数组中的众数。

Boyer-Moore 算法的正确性较难证明，这里给出一种较为详细的用例子辅助证明的思路，供读者参考：

首先我们根据算法步骤中对 count 的定义，可以发现：在对整个数组进行遍历的过程中，count 的值一定非负。这是因为如果 count 的值为 0，那么在这一轮遍历的开始时刻，我们会将 x 的值赋予 candidate 并在接下来的一步中将 count 的值增加 1。因此 count 的值在遍历的过程中一直保持非负。

那么 count 本身除了计数器之外，还有什么更深层次的意义呢？我们还是以数组


[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
作为例子，首先写下它在每一步遍历时 candidate 和 count 的值：


nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
candidate:  7  7  7  7  7  7   5  5   5  5  5  5   7  7  7  7
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
我们再定义一个变量 value，它和真正的众数 maj 绑定。在每一步遍历时，如果当前的数 x 和 maj 相等，那么 value 的值加 1，否则减 1。value 的实际意义即为：到当前的这一步遍历为止，众数出现的次数比非众数多出了多少次。我们将 value 的值也写在下方：


nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4
有没有发现什么？我们将 count 和 value 放在一起：


nums:      [7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]
count:      1  2  1  2  1  0   1  0   1  2  1  0   1  2  3  4
value:      1  2  1  2  1  0  -1  0  -1 -2 -1  0   1  2  3  4
发现在每一步遍历中，count 和 value 要么相等，要么互为相反数！并且在候选众数 candidate 就是 maj 时，它们相等，candidate 是其它的数时，它们互为相反数！

为什么会有这么奇妙的性质呢？这并不难证明：我们将候选众数 candidate 保持不变的连续的遍历称为「一段」。在同一段中，count 的值是根据 candidate == x 的判断进行加减的。那么如果 candidate 恰好为 maj，那么在这一段中，count 和 value 的变化是同步的；如果 candidate 不为 maj，那么在这一段中 count 和 value 的变化是相反的。因此就有了这样一个奇妙的性质。

这样以来，由于：

我们证明了 count 的值一直为非负，在最后一步遍历结束后也是如此；

由于 value 的值与真正的众数 maj 绑定，并且它表示「众数出现的次数比非众数多出了多少次」，那么在最后一步遍历结束后，value 的值为正数；

在最后一步遍历结束后，count 非负，value 为正数，所以它们不可能互为相反数，只可能相等，即 count == value。因此在最后「一段」中，count 的 value 的变化是同步的，也就是说，candidate 中存储的候选众数就是真正的众数 maj



```java
class Solution {
public int majorityElement(int[] nums) {

    // 初始化一个候选人candidate，和他的计票
    int cand1 = nums[0], count1 = 0;

    // 摩尔投票法，分为两个阶段：配对阶段和计数阶段
    // 配对阶段
    for (int num : nums) {
        // 投票
        if (cand1 == num) {
            count1++;
        }else{
            count1--;
            if(count1 == 0)
            {
                cand1 = num;
                count1 = 1;
            }
        }
    }
    return cand1;
}
}
```

### 49丑数（特么的，数字都要开始卷了吗！！）

**题目：**

​		我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

**示例：**

```java
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

**思路：**

​		假如现在已经存在了一个丑数序列（X0,X1.....Xi-1）,那么要求第i个丑数，根据丑数的性质，第i个丑数只能是下列三种情况之一

![image-20210708163444956](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20210708163444956.png)

且第i个丑数为其中的最小值。

贴一个转载的更加详细的思路地址：https://leetcode-cn.com/u/admiring-faraday/

我的一点理解： 在已有的丑数序列上每一个数都必须乘2， 乘3， 乘5， 这样才不会漏掉某些丑数。假设已有的丑数序列为[1, 2, 3, ..., n1, n2], 如果单纯的让每个丑数乘2， 乘3， 乘5顺序排列的话肯定会有问题，

比如如果按照这样的顺序排列下去肯定有问题[1*2, 1*3, 1*5, 2*2, 2*3, 2*5, 3*2, 3*3, 3*5, ... , n1 *2, n1 * 3, n1 * 5, n2 * 2, n3* 3, n2 * 5]，因为后面乘2的数据可能会比前面乘3乘5的数据要小，那这个乘2的数应该排在他们的前面， 后面乘3的数据也可能比前面乘5的数据要小，那这个乘3的数应该排在他们的前面。

那怎么办呢，每个数都必须乘2， 乘3， 乘5这样才能保证求出所有的丑数，而且还要保证丑数的顺序，这个改如何同时实现呢？

通过观察网上的各个题解，终于找到了办法，那就是记录每个丑数是否已经被乘2， 乘3， 乘5了， 具体的做法是

设置3个索引a, b, c，分别记录前几个数已经被乘2， 乘3， 乘5了，比如a表示前(a-1)个数都已经乘过一次2了，下次应该乘2的是第a个数；b表示前(b-1)个数都已经乘过一次3了，下次应该乘3的是第b个数；c表示前(c-1)个数都已经乘过一次5了，下次应该乘5的是第c个数；

对于某个状态下的丑数序列，我们知道此时第a个数还没有乘2(有没有乘3或者乘5不知道）， 第b个数还没有乘3(有没有乘2或者乘5不知道），第c个数还没有乘5(有没有乘2或者乘3不知道), 下一个丑数一定是从第a丑数乘2， 第b个数乘3， 第c个数乘5中获得，他们三者最小的那个就是下个丑数。

求得下个丑数后就得判断这个丑数是谁，是某个数通过乘2得到的，还是某个数乘3得到的，又或是说某个数通过乘5得到的。我们可以比较一下这个新的丑数等于究竟是等于第a个丑数乘2, 还是第b个数乘3， 还是第c个数乘5， 通过比较我们肯定可以知道这个新的丑数到底是哪个数通过乘哪个数得到的。假设这个新的丑数是通过第a个数乘2得到的，说明此时第a个数已经通过乘2得到了一个新的丑数，那下个通过乘2得到一个新的丑数的数应该是第(a+1)个数，此时我们可以说前 a 个数都已经乘过一次2了，下次应该乘2的是第 （a+1） 个数, 所以a++；如果新的丑数是通过第b个数乘3得到的, 说明此时第 b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数，此时我们可以说前 b 个数都已经乘过一次3了，下次应该乘3的是第 （b+1） 个数, 所以 b++；同理，如果这个这个新的丑数是通过第c个数乘5得到的, 那么c++;

但是注意，如果第a个数乘2后等于第b个数乘3，或者等于第c个数乘5， 说明这个新的丑数是有两种或者三种方式可以得到，这时应该给得到这个新丑数的组合对应的索引都加一，比如新丑数是第a个数乘2后和第b个数乘3得到的，那么 a 和 b都应该加一， 因为此时第a个数已经通过乘2得到了一个新的丑数，第b个数已经通过乘3得到了一个新的丑数, 只不过这两个数相等而已。所以我们给计数器加一的时候不能使用 if else else if， 而应该使用if, if, if, 这样才不会把应该加一的计数器漏掉

经过n次循环，就能得到第n 个丑数了。

**注释型题解:**

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n];  // 使用dp数组来存储丑数序列
        dp[0] = 1;  // dp[0]已知为1
        int a = 0, b = 0, c = 0;    // 下个应该通过乘2来获得新丑数的数据是第a个， 同理b, c

        for(int i = 1; i < n; i++){
            // 第a丑数个数需要通过乘2来得到下个丑数，第b丑数个数需要通过乘2来得到下个丑数，同理第c个数
            int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;
            dp[i] = Math.min(Math.min(n2, n3), n5);
            if(dp[i] == n2){
                a++; // 第a个数已经通过乘2得到了一个新的丑数，那下个需要通过乘2得到一个新的丑数的数应该是第(a+1)个数
            }
            if(dp[i] == n3){
                b++; // 第 b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数
            }
            if(dp[i] == n5){
                c++; // 第 c个数已经通过乘5得到了一个新的丑数，那下个需要通过乘5得到一个新的丑数的数应该是第(c+1)个数
            }
        }
        return dp[n-1];
    }
}
```



### 58 左旋转字符串

**题目：**字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

**额外要求：不能申请额外空间，只能在本串上操作**。

**示例：**

```java
示例 1：
输入: s = "abcdefg", k = 2
输出: "cdefgab"

示例 2：
输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
```

**解题思路：**我们可以通过以下的三步来进行左旋转字符串

1. 反转前k个字符

2. 反转第k个字符到最后一个字符

3. 反转整个字符串

   这样就完成了左旋转字符串。 同样，进行以下三步可以右旋转字符串：

   1. 反转倒数k个字符
   2. 反转倒数第k个字符到第一个字符。
   3. 反转整个字符串

**代码：**

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        int len=s.length();
        StringBuilder sb=new StringBuilder(s);
        reverseString(sb,0,n-1);
        reverseString(sb,n,len-1);
        return sb.reverse().toString();
    }
     public void reverseString(StringBuilder sb, int start, int end) {
        while (start < end) {
            char temp = sb.charAt(start);
            sb.setCharAt(start, sb.charAt(end));
            sb.setCharAt(end, temp);
            start++;
            end--;
            }
        }
}
```



### 60 n个骰子的点数

**题目：**把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

**示例 1:**

```
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
```

**示例 2:**

```
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
```

**状态：**

​	第n枚骰子投掷完后总点数出现的次数，记为dp[n] [sum]

**状态转移方程：**

![img](file:///C:/Users/pc/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)

**边界值：**

​	投一枚骰子的点数和的次数的可能，即

​	dp[1] [i] = 1,(1<=i<=6)

**最后：**

​	n枚骰子的点数和 的总可能 是 6的n次方 total = 6^n   , 所以概率值 p[i] = dp[n] [i] / total

**注释型题解：**

```java
class Solution {
    public double[] dicesProbability(int n) {

        //计算总的可能性 每个骰子的点数为1-6 n枚骰子的排列组合为 6的n次方
        int total = (int)Math.pow(6,n);

        //创建状态转移数组 下标从1开始  所以 n枚骰子 初始化为n+1 同时点数和最大值为6*n 所以初始化为6*n+1
        int[][] dp = new int[n+1][6*n+1];

        //初始化边界值 投掷一枚骰子时 出现点数的可能次数 出现1-6的点数和 次数分别都为1
        for( int i=1;i<=6;i++)
        {
            dp[1][i] = 1;
        }
        //从第二枚骰子开始计算一直到第n枚骰子
        for(int i=2;i<=n;i++)
        {
            //此时最小的点数为i 最大的点数为6*i 
            for(int j=i;j<=6*i;j++)
            {
                    //计算每一个点数出现的次数
                    for(int k=1;k<=6;k++)
                    {
                        //说明次数要丢出0点及以下 才能满足情况了 直接丢弃这种情况
                        if(j-k <=0)
                        {
                            break;
                        }
                        //状态转移方程 否则就累加进来
                        dp[i][j] += dp[i-1][j-k];
                    }
            }
        }
        double[] res = new double[5*n+1];
        //次数完成之后计算每个次数的概率
        for(int i = n;i<= 6*n; i++)
        {
            res[i-n] = (double)dp[n][i] / total;
        }
        return res;
    }
}
```

### 63 买卖股票的最佳时机

**题目：**

	给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
	你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
	返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

**示例：**

```java
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

**解题思路:**

​	首先我们应该知道利润怎么算，**利润 = 卖出价 - 买入价**，我们用 profit[i]  来代表以数组中第 i 个的元素的价格卖出可能获得的最大利润，那么此时我们的卖出价是固定的，根据公式，我们需要得到最低的买入价，才能获得最大的利润！也就是我们要获得前 i-1个元素的最低价格。注意此时的最大利润是可能，而不是一定的，请读者自行思考一下。

**代码：**

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length < 2)
        {
            return 0;
        }
        int min = prices[0];
        int max = prices[1] - min;
        for(int i=2;i<prices.length;i++)
        {
             if(prices[i-1] < min)
            {
                min = prices[i-1];
            } 
            int curMax = prices[i] - min;
            if(curMax > max)
            {
                max =curMax;
            }
        }
        if(max < 0)
        {
            return 0;
        }
        return max;

    }
}
```

